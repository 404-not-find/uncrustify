All items are integers.
All items default to 0, unless otherwise specified.

Values can be one of:
	n : number parsed with strtoul()
	0 : anything not covered below
	1 : "true", "yes", "add", "insert", "on" == 1
	2 : "del", "rem", "remove" == 2
	3 : "force"


indent:
	Control whether re-indenting is done.
	Most other features won't work without this option.
	0 = don't change indentation
	1 = change indentation
	default: 0

input_tab_size:
	tab size on input file.
	default: 8

output_tab_size:
	tab size for output.
	default: 8

indent_columns:
	The number of columns to indent per level.
	Typically matches the tab size.
	default: 8

indent_with_tabs:
	Controls whether left-column indenting is done with tabs, spaces, or
	a combination of the two.
	0 = use spaces
	1 = use tabs to indent to the 'level', use spaces afterwards
	2 = always use tabs for indenting
	default: 1

align_with_tabs:
	Use tabs for aligning code.
	0 = Use spaces only
	1 = use tabs and spaces
	default: 0
	
align_on_tabstop:
	Shift alignment right to a tabstop
	0 = don't
	1 = align on tabstop
	default: 0

indent_brace_struct:
	The number of columns to indent the open brace after struct/enum/union
	definition.
	default: 0
	

# UO_indent_paren,         // indent for open paren on next line (1)
# UO_leave_preproc_space,  // if true, leave the spaces between '#' and preprocessor commands
# UO_pp_indent,            // spaces to indent preprocessors (0)
# UO_indent_if_body,       // indent non-braced if/while/for bodies

case_indent:
	The number of columns to indent case from switch.
	Usually 0 or the tab size.
	default: 0

# UO_case_brace_indent,    // spaces to indent '{' from case

brace_indent:
	Columns to indent '{' from level.  Usually 0.
	Non-zero values don't mesh well with a cuddled else.
	default: 0

indent_func_param:
	If a newline immediately follows the '(' in a function declaration,
	indent to this column.
	0 = use paren indent
	1 = column 1, etc
	default: 0
	
label_indent:
	Declares how to indent labels.
	>=0 = columns from the left (0=column 1, 1=column 2, etc)
	<0  = add to brace indent level (-8=back out 8 columns)
        default: 0
	
indent_align_string:
	Align broken strings on the opening of the previous string.
	0 = do not align
	1 = align
	default: 0


INTER-SYMBOL SPACING
--------------------
All inter-symbol spacing options take one of three values:
  0 : don't change it
  1 : add a space (will not remove excess; ensures at least 1 space/tab)
  2 : remove spaces
  3 : insert exactly one space (remove excess)

These options are prefixed with "sp_".
The default is 0.

sp_before_sparen:
	Space before the '(' of 'if/for/while/switch' statements
	
sp_after_sparen:
	Space after  ')' of 'if/for/while/switch'.
        This does not affect ')' of do-while statemenst.
	
sp_paren_brace:
	Space between ')' and '{'

sp_after_cast:
	Space after cast - "(int) a" vs "(int)a"

sp_inside_paren:
	Space inside parens - '( x )' vs '(x)'
	
sp_paren_paren:
	Space between open/close parens - '( (' vs '(('

sp_return_paren:
	Space between 'return' and '(' - 'return (a)' vs 'return(a)'
	
sp_sizeof_paren:
	Space between 'sizeof' and '(' - 'sizeof (a)' vs 'sizeof(a)'

sp_func_def_paren:
	Space between function definition and '(' - "int foo (..." vs "int foo(..."
	
sp_func_call_paren:
	Space between function call and '(' - "foo (" vs "foo("
	
sp_func_proto_paren:
	Space between function prototype and '(' - "int foo (" vs "int foo("
	
sp_special_semi:
	Space before empty statement - "while (*a++) ;" vs "while (*a++);"
	Example "while (*p++ = ' ') ;"
	
sp_before_semi:
	Space before all ';' - "i = 5 ;" vs "i = 5;"
	
sp_inside_braces:
	Space inside '{' and '}' - "{ 1, 2, 3 }" vs "{1, 2, 3}"
	
sp_inside_braces_enum:
	Space inside enum defintion '{' and '}' - "{ a, b, c }"
	
sp_inside_braces_struct:
	Space inside struct/union definition '{' and '}'

TODO:
sp_arith:
	Spaces around arithmetic punctuators +, -, /, *, <<, etc

sp_after_comma:
	Space after all commas - "a, b, c" vs "a,b,c"


   /*
    * Line splitting options (for long lines)
    */

   UO_code_width,           // ie 80 columns
   UO_ls_before_bool_op,    // break line before of after boolean op
   UO_ls_before_paren,      // break before open paren
   UO_ls_after_arith,       // break after arith op '+', etc
   UO_ls_honor_newlines,    // don't remove newlines on split lines


   /*
    * code alignment (not left column spaces/tabs)
    */

   UO_align_nl_cont,              // align the back-slash \n combo (in macros)
   UO_align_enum_equ,             // align the '=' in enums
   UO_align_assign_span,          // align on '='. 0=don't align
   UO_align_right_cmt_span,       // align comment that end lines. 0=don't align
   UO_align_var_def_span,         // align variable defs on variable (span for regular stuff)
   UO_align_var_def_inline,       // also align inline struct/enum/union var defs
   UO_align_var_def_star,         // the star is part of the variable name
   UO_align_var_def_colon,        // align the colon in struct bit fields
   UO_align_var_struct_span,      // span for struct/union (0=don't align)
   UO_align_pp_define_span,       // align bodies in #define statments
   UO_align_pp_define_col_min,
   UO_align_pp_define_col_max,
   UO_align_pp_define_gap,
   UO_align_enum_col_min,        // the minimum column for enum '=' alignment
   UO_align_enum_col_max,
   UO_align_struct_init_span,    // align structure initializer values
   UO_align_func_proto_span,     // align function prototypes


   /*
    * Newline adding and removing options
    */

   UO_nl_fdef_brace,          // "int foo() {" vs "int foo()\n{"
   UO_nl_func_decl_args,      // newline after each ',' in a function decl
   UO_nl_func_decl_end,       // newline before the ')' in a multi-line function decl
   UO_nl_func_type_name,      // newline between return type and func name in def
   UO_nl_func_var_def_blk,    // newline after a block of variable defs
   UO_nl_before_case,         // newline before 'case' statement
   UO_nl_after_return,        /* newline after return statement */
   UO_nl_after_case,          /* disallow nested "case 1: a=3;" */
   UO_nl_fcall_brace,         /* newline between function call and open brace */

   UO_nl_squeeze_ifdef,       /* no blanks after #ifxx, #elxx, or before #endf */

   UO_nl_enum_brace,          /* nl between enum and brace */
   UO_nl_struct_brace,        /* nl between struct and brace */
   UO_nl_union_brace,         /* nl between union and brace */

   UO_nl_do_brace,            /* nl between do and brace */
   UO_nl_if_brace,            /* nl between if and brace */
   UO_nl_for_brace,           /* nl between for and brace */
   UO_nl_else_brace,          /* nl between else and brace */
   UO_nl_while_brace,         /* nl between while and brace */
   UO_nl_switch_brace,        /* nl between switch and brace */
   UO_nl_brace_while,         // nl between brace and while of do
   UO_nl_brace_else,          // nl between brace and else

   /*
    * Blank line options
    */

   UO_blc_before_block_comment,
   UO_blc_after_func_body,
   UO_blc_after_func_proto,         // after each prototype
   UO_blc_after_func_proto_group,   // after a block of prototypes
   UO_blc_after_var_def_group,      // after a group of variable defs at top of proc
   UO_blc_after_ifdef,              // after #if or #ifdef - but not if covers whole file
   UO_bl_max_count,                 // maximum consecutive newlines (3 is good)

   UO_eat_blanks_after_open_brace,
   UO_eat_blanks_before_close_brace,

   /*
    * code modifying options (non-whitespace)
    */

   UO_mod_paren_on_return,
   UO_mod_full_brace,


   /*
    * Comment modifications
    */

   UO_cmt_reformat,        // reformat non-col 1 comments (FALSE)
   UO_cmt_reformat_col1,   // reformat col-1 comments (FALSE)
   UO_cmt_star_cont,       // put a star on subsequent comment lines
   UO_cmt_nl_multi_open,   // newline after opening slash-star in multi-line comments
   UO_cmt_nl_multi_close,  // newline before closing star-slash in multi-line comments
   UO_cmt_columns,         // max column for comments
   UO_cmt_else_endif_col,  // column for comments following #else or #endif
   UO_cmt_left_col_min,    // min column for comments following code

   UO_verbose,             /* when true, non-essential error messages are printed */
   UO_use_stdout,          /* Where does output go. */
   UO_preserve_mtime,      /* True when the modification time of the files should  be preserved. */

   UO_lineup_to_parens,    /* if true, continued code within parens will be lined up to the open paren */

//?   int ljust_decl,          /* true if declarations should be left justified */

   UO_break_function_decl_args,     /* true if declarations should have args on new lines */
   UO_break_function_decl_args_end, /* true if declarations should have
                                     * ")" after args on new lines */
   UO_leave_comma,                  /* if true, never break declarations after commas */
   UO_break_before_boolean_operator,       /* True when we prefer to break a long line
                                            * before a '&&' or '||', instead of behind it.
                                            */

   UO_blanklines_around_conditional_compilation,

//?   int indent_parameters,  /* Number of spaces to indent parameters.  */
//?   int decl_indent,        /* column to indent declared identifiers to */
//?   int unindent_displace,  /* comments not to the right of code will be placed this many indentation levels to the left of code */

//?   int continuation_indent, /* set to the indentation between the edge of code and continuation lines in spaces */
//?   int decl_com_ind,        /* the column in which comments after declarations should be put */

   UO_com_ind,             /* the column in which comments to the right of code should start */

   UO_expect_output_file,  /* Means "-o" was specified. */

   /* This is used to get the enumeration count */
   UO_option_count

